package cert_manager

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

//go:generate minimock -i net.Conn -o ./conn_mock_test.go

import (
	mm_net "net"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ConnMock implements net.Conn
type ConnMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mConnMockClose

	funcLocalAddr          func() (a1 mm_net.Addr)
	inspectFuncLocalAddr   func()
	afterLocalAddrCounter  uint64
	beforeLocalAddrCounter uint64
	LocalAddrMock          mConnMockLocalAddr

	funcRead          func(b []byte) (n int, err error)
	inspectFuncRead   func(b []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mConnMockRead

	funcRemoteAddr          func() (a1 mm_net.Addr)
	inspectFuncRemoteAddr   func()
	afterRemoteAddrCounter  uint64
	beforeRemoteAddrCounter uint64
	RemoteAddrMock          mConnMockRemoteAddr

	funcSetDeadline          func(t time.Time) (err error)
	inspectFuncSetDeadline   func(t time.Time)
	afterSetDeadlineCounter  uint64
	beforeSetDeadlineCounter uint64
	SetDeadlineMock          mConnMockSetDeadline

	funcSetReadDeadline          func(t time.Time) (err error)
	inspectFuncSetReadDeadline   func(t time.Time)
	afterSetReadDeadlineCounter  uint64
	beforeSetReadDeadlineCounter uint64
	SetReadDeadlineMock          mConnMockSetReadDeadline

	funcSetWriteDeadline          func(t time.Time) (err error)
	inspectFuncSetWriteDeadline   func(t time.Time)
	afterSetWriteDeadlineCounter  uint64
	beforeSetWriteDeadlineCounter uint64
	SetWriteDeadlineMock          mConnMockSetWriteDeadline

	funcWrite          func(b []byte) (n int, err error)
	inspectFuncWrite   func(b []byte)
	afterWriteCounter  uint64
	beforeWriteCounter uint64
	WriteMock          mConnMockWrite
}

// NewConnMock returns a mock for net.Conn
func NewConnMock(t minimock.Tester) *ConnMock {
	m := &ConnMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mConnMockClose{mock: m}

	m.LocalAddrMock = mConnMockLocalAddr{mock: m}

	m.ReadMock = mConnMockRead{mock: m}
	m.ReadMock.callArgs = []*ConnMockReadParams{}

	m.RemoteAddrMock = mConnMockRemoteAddr{mock: m}

	m.SetDeadlineMock = mConnMockSetDeadline{mock: m}
	m.SetDeadlineMock.callArgs = []*ConnMockSetDeadlineParams{}

	m.SetReadDeadlineMock = mConnMockSetReadDeadline{mock: m}
	m.SetReadDeadlineMock.callArgs = []*ConnMockSetReadDeadlineParams{}

	m.SetWriteDeadlineMock = mConnMockSetWriteDeadline{mock: m}
	m.SetWriteDeadlineMock.callArgs = []*ConnMockSetWriteDeadlineParams{}

	m.WriteMock = mConnMockWrite{mock: m}
	m.WriteMock.callArgs = []*ConnMockWriteParams{}

	return m
}

type mConnMockClose struct {
	mock               *ConnMock
	defaultExpectation *ConnMockCloseExpectation
	expectations       []*ConnMockCloseExpectation
}

// ConnMockCloseExpectation specifies expectation struct of the Conn.Close
type ConnMockCloseExpectation struct {
	mock *ConnMock

	results *ConnMockCloseResults
	Counter uint64
}

// ConnMockCloseResults contains results of the Conn.Close
type ConnMockCloseResults struct {
	err error
}

// Expect sets up expected params for Conn.Close
func (mmClose *mConnMockClose) Expect() *mConnMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ConnMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ConnMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Conn.Close
func (mmClose *mConnMockClose) Inspect(f func()) *mConnMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ConnMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Conn.Close
func (mmClose *mConnMockClose) Return(err error) *ConnMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ConnMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ConnMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ConnMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the Conn.Close method
func (mmClose *mConnMockClose) Set(f func() (err error)) *ConnMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Conn.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Conn.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements net.Conn
func (mmClose *ConnMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ConnMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ConnMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ConnMock.Close invocations
func (mmClose *ConnMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ConnMock.Close invocations
func (mmClose *ConnMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ConnMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ConnMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ConnMock.Close")
	}
}

type mConnMockLocalAddr struct {
	mock               *ConnMock
	defaultExpectation *ConnMockLocalAddrExpectation
	expectations       []*ConnMockLocalAddrExpectation
}

// ConnMockLocalAddrExpectation specifies expectation struct of the Conn.LocalAddr
type ConnMockLocalAddrExpectation struct {
	mock *ConnMock

	results *ConnMockLocalAddrResults
	Counter uint64
}

// ConnMockLocalAddrResults contains results of the Conn.LocalAddr
type ConnMockLocalAddrResults struct {
	a1 mm_net.Addr
}

// Expect sets up expected params for Conn.LocalAddr
func (mmLocalAddr *mConnMockLocalAddr) Expect() *mConnMockLocalAddr {
	if mmLocalAddr.mock.funcLocalAddr != nil {
		mmLocalAddr.mock.t.Fatalf("ConnMock.LocalAddr mock is already set by Set")
	}

	if mmLocalAddr.defaultExpectation == nil {
		mmLocalAddr.defaultExpectation = &ConnMockLocalAddrExpectation{}
	}

	return mmLocalAddr
}

// Inspect accepts an inspector function that has same arguments as the Conn.LocalAddr
func (mmLocalAddr *mConnMockLocalAddr) Inspect(f func()) *mConnMockLocalAddr {
	if mmLocalAddr.mock.inspectFuncLocalAddr != nil {
		mmLocalAddr.mock.t.Fatalf("Inspect function is already set for ConnMock.LocalAddr")
	}

	mmLocalAddr.mock.inspectFuncLocalAddr = f

	return mmLocalAddr
}

// Return sets up results that will be returned by Conn.LocalAddr
func (mmLocalAddr *mConnMockLocalAddr) Return(a1 mm_net.Addr) *ConnMock {
	if mmLocalAddr.mock.funcLocalAddr != nil {
		mmLocalAddr.mock.t.Fatalf("ConnMock.LocalAddr mock is already set by Set")
	}

	if mmLocalAddr.defaultExpectation == nil {
		mmLocalAddr.defaultExpectation = &ConnMockLocalAddrExpectation{mock: mmLocalAddr.mock}
	}
	mmLocalAddr.defaultExpectation.results = &ConnMockLocalAddrResults{a1}
	return mmLocalAddr.mock
}

//Set uses given function f to mock the Conn.LocalAddr method
func (mmLocalAddr *mConnMockLocalAddr) Set(f func() (a1 mm_net.Addr)) *ConnMock {
	if mmLocalAddr.defaultExpectation != nil {
		mmLocalAddr.mock.t.Fatalf("Default expectation is already set for the Conn.LocalAddr method")
	}

	if len(mmLocalAddr.expectations) > 0 {
		mmLocalAddr.mock.t.Fatalf("Some expectations are already set for the Conn.LocalAddr method")
	}

	mmLocalAddr.mock.funcLocalAddr = f
	return mmLocalAddr.mock
}

// LocalAddr implements net.Conn
func (mmLocalAddr *ConnMock) LocalAddr() (a1 mm_net.Addr) {
	mm_atomic.AddUint64(&mmLocalAddr.beforeLocalAddrCounter, 1)
	defer mm_atomic.AddUint64(&mmLocalAddr.afterLocalAddrCounter, 1)

	if mmLocalAddr.inspectFuncLocalAddr != nil {
		mmLocalAddr.inspectFuncLocalAddr()
	}

	if mmLocalAddr.LocalAddrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLocalAddr.LocalAddrMock.defaultExpectation.Counter, 1)

		mm_results := mmLocalAddr.LocalAddrMock.defaultExpectation.results
		if mm_results == nil {
			mmLocalAddr.t.Fatal("No results are set for the ConnMock.LocalAddr")
		}
		return (*mm_results).a1
	}
	if mmLocalAddr.funcLocalAddr != nil {
		return mmLocalAddr.funcLocalAddr()
	}
	mmLocalAddr.t.Fatalf("Unexpected call to ConnMock.LocalAddr.")
	return
}

// LocalAddrAfterCounter returns a count of finished ConnMock.LocalAddr invocations
func (mmLocalAddr *ConnMock) LocalAddrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLocalAddr.afterLocalAddrCounter)
}

// LocalAddrBeforeCounter returns a count of ConnMock.LocalAddr invocations
func (mmLocalAddr *ConnMock) LocalAddrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLocalAddr.beforeLocalAddrCounter)
}

// MinimockLocalAddrDone returns true if the count of the LocalAddr invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockLocalAddrDone() bool {
	for _, e := range m.LocalAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LocalAddrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLocalAddrCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLocalAddr != nil && mm_atomic.LoadUint64(&m.afterLocalAddrCounter) < 1 {
		return false
	}
	return true
}

// MinimockLocalAddrInspect logs each unmet expectation
func (m *ConnMock) MinimockLocalAddrInspect() {
	for _, e := range m.LocalAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnMock.LocalAddr")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LocalAddrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLocalAddrCounter) < 1 {
		m.t.Error("Expected call to ConnMock.LocalAddr")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLocalAddr != nil && mm_atomic.LoadUint64(&m.afterLocalAddrCounter) < 1 {
		m.t.Error("Expected call to ConnMock.LocalAddr")
	}
}

type mConnMockRead struct {
	mock               *ConnMock
	defaultExpectation *ConnMockReadExpectation
	expectations       []*ConnMockReadExpectation

	callArgs []*ConnMockReadParams
	mutex    sync.RWMutex
}

// ConnMockReadExpectation specifies expectation struct of the Conn.Read
type ConnMockReadExpectation struct {
	mock    *ConnMock
	params  *ConnMockReadParams
	results *ConnMockReadResults
	Counter uint64
}

// ConnMockReadParams contains parameters of the Conn.Read
type ConnMockReadParams struct {
	b []byte
}

// ConnMockReadResults contains results of the Conn.Read
type ConnMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for Conn.Read
func (mmRead *mConnMockRead) Expect(b []byte) *mConnMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &ConnMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &ConnMockReadParams{b}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the Conn.Read
func (mmRead *mConnMockRead) Inspect(f func(b []byte)) *mConnMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for ConnMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by Conn.Read
func (mmRead *mConnMockRead) Return(n int, err error) *ConnMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &ConnMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &ConnMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the Conn.Read method
func (mmRead *mConnMockRead) Set(f func(b []byte) (n int, err error)) *ConnMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the Conn.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the Conn.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the Conn.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mConnMockRead) When(b []byte) *ConnMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Set")
	}

	expectation := &ConnMockReadExpectation{
		mock:   mmRead.mock,
		params: &ConnMockReadParams{b},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up Conn.Read return parameters for the expectation previously defined by the When method
func (e *ConnMockReadExpectation) Then(n int, err error) *ConnMock {
	e.results = &ConnMockReadResults{n, err}
	return e.mock
}

// Read implements net.Conn
func (mmRead *ConnMock) Read(b []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(b)
	}

	mm_params := &ConnMockReadParams{b}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, mm_params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRead.ReadMock.defaultExpectation.params
		mm_got := ConnMockReadParams{b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRead.t.Errorf("ConnMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the ConnMock.Read")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(b)
	}
	mmRead.t.Fatalf("Unexpected call to ConnMock.Read. %v", b)
	return
}

// ReadAfterCounter returns a count of finished ConnMock.Read invocations
func (mmRead *ConnMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of ConnMock.Read invocations
func (mmRead *ConnMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mConnMockRead) Calls() []*ConnMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*ConnMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *ConnMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.Read")
		} else {
			m.t.Errorf("Expected call to ConnMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to ConnMock.Read")
	}
}

type mConnMockRemoteAddr struct {
	mock               *ConnMock
	defaultExpectation *ConnMockRemoteAddrExpectation
	expectations       []*ConnMockRemoteAddrExpectation
}

// ConnMockRemoteAddrExpectation specifies expectation struct of the Conn.RemoteAddr
type ConnMockRemoteAddrExpectation struct {
	mock *ConnMock

	results *ConnMockRemoteAddrResults
	Counter uint64
}

// ConnMockRemoteAddrResults contains results of the Conn.RemoteAddr
type ConnMockRemoteAddrResults struct {
	a1 mm_net.Addr
}

// Expect sets up expected params for Conn.RemoteAddr
func (mmRemoteAddr *mConnMockRemoteAddr) Expect() *mConnMockRemoteAddr {
	if mmRemoteAddr.mock.funcRemoteAddr != nil {
		mmRemoteAddr.mock.t.Fatalf("ConnMock.RemoteAddr mock is already set by Set")
	}

	if mmRemoteAddr.defaultExpectation == nil {
		mmRemoteAddr.defaultExpectation = &ConnMockRemoteAddrExpectation{}
	}

	return mmRemoteAddr
}

// Inspect accepts an inspector function that has same arguments as the Conn.RemoteAddr
func (mmRemoteAddr *mConnMockRemoteAddr) Inspect(f func()) *mConnMockRemoteAddr {
	if mmRemoteAddr.mock.inspectFuncRemoteAddr != nil {
		mmRemoteAddr.mock.t.Fatalf("Inspect function is already set for ConnMock.RemoteAddr")
	}

	mmRemoteAddr.mock.inspectFuncRemoteAddr = f

	return mmRemoteAddr
}

// Return sets up results that will be returned by Conn.RemoteAddr
func (mmRemoteAddr *mConnMockRemoteAddr) Return(a1 mm_net.Addr) *ConnMock {
	if mmRemoteAddr.mock.funcRemoteAddr != nil {
		mmRemoteAddr.mock.t.Fatalf("ConnMock.RemoteAddr mock is already set by Set")
	}

	if mmRemoteAddr.defaultExpectation == nil {
		mmRemoteAddr.defaultExpectation = &ConnMockRemoteAddrExpectation{mock: mmRemoteAddr.mock}
	}
	mmRemoteAddr.defaultExpectation.results = &ConnMockRemoteAddrResults{a1}
	return mmRemoteAddr.mock
}

//Set uses given function f to mock the Conn.RemoteAddr method
func (mmRemoteAddr *mConnMockRemoteAddr) Set(f func() (a1 mm_net.Addr)) *ConnMock {
	if mmRemoteAddr.defaultExpectation != nil {
		mmRemoteAddr.mock.t.Fatalf("Default expectation is already set for the Conn.RemoteAddr method")
	}

	if len(mmRemoteAddr.expectations) > 0 {
		mmRemoteAddr.mock.t.Fatalf("Some expectations are already set for the Conn.RemoteAddr method")
	}

	mmRemoteAddr.mock.funcRemoteAddr = f
	return mmRemoteAddr.mock
}

// RemoteAddr implements net.Conn
func (mmRemoteAddr *ConnMock) RemoteAddr() (a1 mm_net.Addr) {
	mm_atomic.AddUint64(&mmRemoteAddr.beforeRemoteAddrCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoteAddr.afterRemoteAddrCounter, 1)

	if mmRemoteAddr.inspectFuncRemoteAddr != nil {
		mmRemoteAddr.inspectFuncRemoteAddr()
	}

	if mmRemoteAddr.RemoteAddrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoteAddr.RemoteAddrMock.defaultExpectation.Counter, 1)

		mm_results := mmRemoteAddr.RemoteAddrMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoteAddr.t.Fatal("No results are set for the ConnMock.RemoteAddr")
		}
		return (*mm_results).a1
	}
	if mmRemoteAddr.funcRemoteAddr != nil {
		return mmRemoteAddr.funcRemoteAddr()
	}
	mmRemoteAddr.t.Fatalf("Unexpected call to ConnMock.RemoteAddr.")
	return
}

// RemoteAddrAfterCounter returns a count of finished ConnMock.RemoteAddr invocations
func (mmRemoteAddr *ConnMock) RemoteAddrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteAddr.afterRemoteAddrCounter)
}

// RemoteAddrBeforeCounter returns a count of ConnMock.RemoteAddr invocations
func (mmRemoteAddr *ConnMock) RemoteAddrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteAddr.beforeRemoteAddrCounter)
}

// MinimockRemoteAddrDone returns true if the count of the RemoteAddr invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockRemoteAddrDone() bool {
	for _, e := range m.RemoteAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteAddrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteAddrCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteAddr != nil && mm_atomic.LoadUint64(&m.afterRemoteAddrCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoteAddrInspect logs each unmet expectation
func (m *ConnMock) MinimockRemoteAddrInspect() {
	for _, e := range m.RemoteAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnMock.RemoteAddr")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteAddrMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoteAddrCounter) < 1 {
		m.t.Error("Expected call to ConnMock.RemoteAddr")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteAddr != nil && mm_atomic.LoadUint64(&m.afterRemoteAddrCounter) < 1 {
		m.t.Error("Expected call to ConnMock.RemoteAddr")
	}
}

type mConnMockSetDeadline struct {
	mock               *ConnMock
	defaultExpectation *ConnMockSetDeadlineExpectation
	expectations       []*ConnMockSetDeadlineExpectation

	callArgs []*ConnMockSetDeadlineParams
	mutex    sync.RWMutex
}

// ConnMockSetDeadlineExpectation specifies expectation struct of the Conn.SetDeadline
type ConnMockSetDeadlineExpectation struct {
	mock    *ConnMock
	params  *ConnMockSetDeadlineParams
	results *ConnMockSetDeadlineResults
	Counter uint64
}

// ConnMockSetDeadlineParams contains parameters of the Conn.SetDeadline
type ConnMockSetDeadlineParams struct {
	t time.Time
}

// ConnMockSetDeadlineResults contains results of the Conn.SetDeadline
type ConnMockSetDeadlineResults struct {
	err error
}

// Expect sets up expected params for Conn.SetDeadline
func (mmSetDeadline *mConnMockSetDeadline) Expect(t time.Time) *mConnMockSetDeadline {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Set")
	}

	if mmSetDeadline.defaultExpectation == nil {
		mmSetDeadline.defaultExpectation = &ConnMockSetDeadlineExpectation{}
	}

	mmSetDeadline.defaultExpectation.params = &ConnMockSetDeadlineParams{t}
	for _, e := range mmSetDeadline.expectations {
		if minimock.Equal(e.params, mmSetDeadline.defaultExpectation.params) {
			mmSetDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDeadline.defaultExpectation.params)
		}
	}

	return mmSetDeadline
}

// Inspect accepts an inspector function that has same arguments as the Conn.SetDeadline
func (mmSetDeadline *mConnMockSetDeadline) Inspect(f func(t time.Time)) *mConnMockSetDeadline {
	if mmSetDeadline.mock.inspectFuncSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("Inspect function is already set for ConnMock.SetDeadline")
	}

	mmSetDeadline.mock.inspectFuncSetDeadline = f

	return mmSetDeadline
}

// Return sets up results that will be returned by Conn.SetDeadline
func (mmSetDeadline *mConnMockSetDeadline) Return(err error) *ConnMock {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Set")
	}

	if mmSetDeadline.defaultExpectation == nil {
		mmSetDeadline.defaultExpectation = &ConnMockSetDeadlineExpectation{mock: mmSetDeadline.mock}
	}
	mmSetDeadline.defaultExpectation.results = &ConnMockSetDeadlineResults{err}
	return mmSetDeadline.mock
}

//Set uses given function f to mock the Conn.SetDeadline method
func (mmSetDeadline *mConnMockSetDeadline) Set(f func(t time.Time) (err error)) *ConnMock {
	if mmSetDeadline.defaultExpectation != nil {
		mmSetDeadline.mock.t.Fatalf("Default expectation is already set for the Conn.SetDeadline method")
	}

	if len(mmSetDeadline.expectations) > 0 {
		mmSetDeadline.mock.t.Fatalf("Some expectations are already set for the Conn.SetDeadline method")
	}

	mmSetDeadline.mock.funcSetDeadline = f
	return mmSetDeadline.mock
}

// When sets expectation for the Conn.SetDeadline which will trigger the result defined by the following
// Then helper
func (mmSetDeadline *mConnMockSetDeadline) When(t time.Time) *ConnMockSetDeadlineExpectation {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Set")
	}

	expectation := &ConnMockSetDeadlineExpectation{
		mock:   mmSetDeadline.mock,
		params: &ConnMockSetDeadlineParams{t},
	}
	mmSetDeadline.expectations = append(mmSetDeadline.expectations, expectation)
	return expectation
}

// Then sets up Conn.SetDeadline return parameters for the expectation previously defined by the When method
func (e *ConnMockSetDeadlineExpectation) Then(err error) *ConnMock {
	e.results = &ConnMockSetDeadlineResults{err}
	return e.mock
}

// SetDeadline implements net.Conn
func (mmSetDeadline *ConnMock) SetDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetDeadline.beforeSetDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDeadline.afterSetDeadlineCounter, 1)

	if mmSetDeadline.inspectFuncSetDeadline != nil {
		mmSetDeadline.inspectFuncSetDeadline(t)
	}

	mm_params := &ConnMockSetDeadlineParams{t}

	// Record call args
	mmSetDeadline.SetDeadlineMock.mutex.Lock()
	mmSetDeadline.SetDeadlineMock.callArgs = append(mmSetDeadline.SetDeadlineMock.callArgs, mm_params)
	mmSetDeadline.SetDeadlineMock.mutex.Unlock()

	for _, e := range mmSetDeadline.SetDeadlineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetDeadline.SetDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDeadline.SetDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDeadline.SetDeadlineMock.defaultExpectation.params
		mm_got := ConnMockSetDeadlineParams{t}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDeadline.t.Errorf("ConnMock.SetDeadline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetDeadline.SetDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetDeadline.t.Fatal("No results are set for the ConnMock.SetDeadline")
		}
		return (*mm_results).err
	}
	if mmSetDeadline.funcSetDeadline != nil {
		return mmSetDeadline.funcSetDeadline(t)
	}
	mmSetDeadline.t.Fatalf("Unexpected call to ConnMock.SetDeadline. %v", t)
	return
}

// SetDeadlineAfterCounter returns a count of finished ConnMock.SetDeadline invocations
func (mmSetDeadline *ConnMock) SetDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDeadline.afterSetDeadlineCounter)
}

// SetDeadlineBeforeCounter returns a count of ConnMock.SetDeadline invocations
func (mmSetDeadline *ConnMock) SetDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDeadline.beforeSetDeadlineCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.SetDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDeadline *mConnMockSetDeadline) Calls() []*ConnMockSetDeadlineParams {
	mmSetDeadline.mutex.RLock()

	argCopy := make([]*ConnMockSetDeadlineParams, len(mmSetDeadline.callArgs))
	copy(argCopy, mmSetDeadline.callArgs)

	mmSetDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetDeadlineDone returns true if the count of the SetDeadline invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockSetDeadlineDone() bool {
	for _, e := range m.SetDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDeadline != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDeadlineInspect logs each unmet expectation
func (m *ConnMock) MinimockSetDeadlineInspect() {
	for _, e := range m.SetDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.SetDeadline with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		if m.SetDeadlineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.SetDeadline")
		} else {
			m.t.Errorf("Expected call to ConnMock.SetDeadline with params: %#v", *m.SetDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDeadline != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		m.t.Error("Expected call to ConnMock.SetDeadline")
	}
}

type mConnMockSetReadDeadline struct {
	mock               *ConnMock
	defaultExpectation *ConnMockSetReadDeadlineExpectation
	expectations       []*ConnMockSetReadDeadlineExpectation

	callArgs []*ConnMockSetReadDeadlineParams
	mutex    sync.RWMutex
}

// ConnMockSetReadDeadlineExpectation specifies expectation struct of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineExpectation struct {
	mock    *ConnMock
	params  *ConnMockSetReadDeadlineParams
	results *ConnMockSetReadDeadlineResults
	Counter uint64
}

// ConnMockSetReadDeadlineParams contains parameters of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineParams struct {
	t time.Time
}

// ConnMockSetReadDeadlineResults contains results of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineResults struct {
	err error
}

// Expect sets up expected params for Conn.SetReadDeadline
func (mmSetReadDeadline *mConnMockSetReadDeadline) Expect(t time.Time) *mConnMockSetReadDeadline {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Set")
	}

	if mmSetReadDeadline.defaultExpectation == nil {
		mmSetReadDeadline.defaultExpectation = &ConnMockSetReadDeadlineExpectation{}
	}

	mmSetReadDeadline.defaultExpectation.params = &ConnMockSetReadDeadlineParams{t}
	for _, e := range mmSetReadDeadline.expectations {
		if minimock.Equal(e.params, mmSetReadDeadline.defaultExpectation.params) {
			mmSetReadDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetReadDeadline.defaultExpectation.params)
		}
	}

	return mmSetReadDeadline
}

// Inspect accepts an inspector function that has same arguments as the Conn.SetReadDeadline
func (mmSetReadDeadline *mConnMockSetReadDeadline) Inspect(f func(t time.Time)) *mConnMockSetReadDeadline {
	if mmSetReadDeadline.mock.inspectFuncSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("Inspect function is already set for ConnMock.SetReadDeadline")
	}

	mmSetReadDeadline.mock.inspectFuncSetReadDeadline = f

	return mmSetReadDeadline
}

// Return sets up results that will be returned by Conn.SetReadDeadline
func (mmSetReadDeadline *mConnMockSetReadDeadline) Return(err error) *ConnMock {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Set")
	}

	if mmSetReadDeadline.defaultExpectation == nil {
		mmSetReadDeadline.defaultExpectation = &ConnMockSetReadDeadlineExpectation{mock: mmSetReadDeadline.mock}
	}
	mmSetReadDeadline.defaultExpectation.results = &ConnMockSetReadDeadlineResults{err}
	return mmSetReadDeadline.mock
}

//Set uses given function f to mock the Conn.SetReadDeadline method
func (mmSetReadDeadline *mConnMockSetReadDeadline) Set(f func(t time.Time) (err error)) *ConnMock {
	if mmSetReadDeadline.defaultExpectation != nil {
		mmSetReadDeadline.mock.t.Fatalf("Default expectation is already set for the Conn.SetReadDeadline method")
	}

	if len(mmSetReadDeadline.expectations) > 0 {
		mmSetReadDeadline.mock.t.Fatalf("Some expectations are already set for the Conn.SetReadDeadline method")
	}

	mmSetReadDeadline.mock.funcSetReadDeadline = f
	return mmSetReadDeadline.mock
}

// When sets expectation for the Conn.SetReadDeadline which will trigger the result defined by the following
// Then helper
func (mmSetReadDeadline *mConnMockSetReadDeadline) When(t time.Time) *ConnMockSetReadDeadlineExpectation {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Set")
	}

	expectation := &ConnMockSetReadDeadlineExpectation{
		mock:   mmSetReadDeadline.mock,
		params: &ConnMockSetReadDeadlineParams{t},
	}
	mmSetReadDeadline.expectations = append(mmSetReadDeadline.expectations, expectation)
	return expectation
}

// Then sets up Conn.SetReadDeadline return parameters for the expectation previously defined by the When method
func (e *ConnMockSetReadDeadlineExpectation) Then(err error) *ConnMock {
	e.results = &ConnMockSetReadDeadlineResults{err}
	return e.mock
}

// SetReadDeadline implements net.Conn
func (mmSetReadDeadline *ConnMock) SetReadDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetReadDeadline.beforeSetReadDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetReadDeadline.afterSetReadDeadlineCounter, 1)

	if mmSetReadDeadline.inspectFuncSetReadDeadline != nil {
		mmSetReadDeadline.inspectFuncSetReadDeadline(t)
	}

	mm_params := &ConnMockSetReadDeadlineParams{t}

	// Record call args
	mmSetReadDeadline.SetReadDeadlineMock.mutex.Lock()
	mmSetReadDeadline.SetReadDeadlineMock.callArgs = append(mmSetReadDeadline.SetReadDeadlineMock.callArgs, mm_params)
	mmSetReadDeadline.SetReadDeadlineMock.mutex.Unlock()

	for _, e := range mmSetReadDeadline.SetReadDeadlineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.params
		mm_got := ConnMockSetReadDeadlineParams{t}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetReadDeadline.t.Errorf("ConnMock.SetReadDeadline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetReadDeadline.t.Fatal("No results are set for the ConnMock.SetReadDeadline")
		}
		return (*mm_results).err
	}
	if mmSetReadDeadline.funcSetReadDeadline != nil {
		return mmSetReadDeadline.funcSetReadDeadline(t)
	}
	mmSetReadDeadline.t.Fatalf("Unexpected call to ConnMock.SetReadDeadline. %v", t)
	return
}

// SetReadDeadlineAfterCounter returns a count of finished ConnMock.SetReadDeadline invocations
func (mmSetReadDeadline *ConnMock) SetReadDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetReadDeadline.afterSetReadDeadlineCounter)
}

// SetReadDeadlineBeforeCounter returns a count of ConnMock.SetReadDeadline invocations
func (mmSetReadDeadline *ConnMock) SetReadDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetReadDeadline.beforeSetReadDeadlineCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.SetReadDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetReadDeadline *mConnMockSetReadDeadline) Calls() []*ConnMockSetReadDeadlineParams {
	mmSetReadDeadline.mutex.RLock()

	argCopy := make([]*ConnMockSetReadDeadlineParams, len(mmSetReadDeadline.callArgs))
	copy(argCopy, mmSetReadDeadline.callArgs)

	mmSetReadDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetReadDeadlineDone returns true if the count of the SetReadDeadline invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockSetReadDeadlineDone() bool {
	for _, e := range m.SetReadDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetReadDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetReadDeadline != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetReadDeadlineInspect logs each unmet expectation
func (m *ConnMock) MinimockSetReadDeadlineInspect() {
	for _, e := range m.SetReadDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.SetReadDeadline with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetReadDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		if m.SetReadDeadlineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.SetReadDeadline")
		} else {
			m.t.Errorf("Expected call to ConnMock.SetReadDeadline with params: %#v", *m.SetReadDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetReadDeadline != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		m.t.Error("Expected call to ConnMock.SetReadDeadline")
	}
}

type mConnMockSetWriteDeadline struct {
	mock               *ConnMock
	defaultExpectation *ConnMockSetWriteDeadlineExpectation
	expectations       []*ConnMockSetWriteDeadlineExpectation

	callArgs []*ConnMockSetWriteDeadlineParams
	mutex    sync.RWMutex
}

// ConnMockSetWriteDeadlineExpectation specifies expectation struct of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineExpectation struct {
	mock    *ConnMock
	params  *ConnMockSetWriteDeadlineParams
	results *ConnMockSetWriteDeadlineResults
	Counter uint64
}

// ConnMockSetWriteDeadlineParams contains parameters of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineParams struct {
	t time.Time
}

// ConnMockSetWriteDeadlineResults contains results of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineResults struct {
	err error
}

// Expect sets up expected params for Conn.SetWriteDeadline
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Expect(t time.Time) *mConnMockSetWriteDeadline {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Set")
	}

	if mmSetWriteDeadline.defaultExpectation == nil {
		mmSetWriteDeadline.defaultExpectation = &ConnMockSetWriteDeadlineExpectation{}
	}

	mmSetWriteDeadline.defaultExpectation.params = &ConnMockSetWriteDeadlineParams{t}
	for _, e := range mmSetWriteDeadline.expectations {
		if minimock.Equal(e.params, mmSetWriteDeadline.defaultExpectation.params) {
			mmSetWriteDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetWriteDeadline.defaultExpectation.params)
		}
	}

	return mmSetWriteDeadline
}

// Inspect accepts an inspector function that has same arguments as the Conn.SetWriteDeadline
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Inspect(f func(t time.Time)) *mConnMockSetWriteDeadline {
	if mmSetWriteDeadline.mock.inspectFuncSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("Inspect function is already set for ConnMock.SetWriteDeadline")
	}

	mmSetWriteDeadline.mock.inspectFuncSetWriteDeadline = f

	return mmSetWriteDeadline
}

// Return sets up results that will be returned by Conn.SetWriteDeadline
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Return(err error) *ConnMock {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Set")
	}

	if mmSetWriteDeadline.defaultExpectation == nil {
		mmSetWriteDeadline.defaultExpectation = &ConnMockSetWriteDeadlineExpectation{mock: mmSetWriteDeadline.mock}
	}
	mmSetWriteDeadline.defaultExpectation.results = &ConnMockSetWriteDeadlineResults{err}
	return mmSetWriteDeadline.mock
}

//Set uses given function f to mock the Conn.SetWriteDeadline method
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Set(f func(t time.Time) (err error)) *ConnMock {
	if mmSetWriteDeadline.defaultExpectation != nil {
		mmSetWriteDeadline.mock.t.Fatalf("Default expectation is already set for the Conn.SetWriteDeadline method")
	}

	if len(mmSetWriteDeadline.expectations) > 0 {
		mmSetWriteDeadline.mock.t.Fatalf("Some expectations are already set for the Conn.SetWriteDeadline method")
	}

	mmSetWriteDeadline.mock.funcSetWriteDeadline = f
	return mmSetWriteDeadline.mock
}

// When sets expectation for the Conn.SetWriteDeadline which will trigger the result defined by the following
// Then helper
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) When(t time.Time) *ConnMockSetWriteDeadlineExpectation {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Set")
	}

	expectation := &ConnMockSetWriteDeadlineExpectation{
		mock:   mmSetWriteDeadline.mock,
		params: &ConnMockSetWriteDeadlineParams{t},
	}
	mmSetWriteDeadline.expectations = append(mmSetWriteDeadline.expectations, expectation)
	return expectation
}

// Then sets up Conn.SetWriteDeadline return parameters for the expectation previously defined by the When method
func (e *ConnMockSetWriteDeadlineExpectation) Then(err error) *ConnMock {
	e.results = &ConnMockSetWriteDeadlineResults{err}
	return e.mock
}

// SetWriteDeadline implements net.Conn
func (mmSetWriteDeadline *ConnMock) SetWriteDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetWriteDeadline.beforeSetWriteDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetWriteDeadline.afterSetWriteDeadlineCounter, 1)

	if mmSetWriteDeadline.inspectFuncSetWriteDeadline != nil {
		mmSetWriteDeadline.inspectFuncSetWriteDeadline(t)
	}

	mm_params := &ConnMockSetWriteDeadlineParams{t}

	// Record call args
	mmSetWriteDeadline.SetWriteDeadlineMock.mutex.Lock()
	mmSetWriteDeadline.SetWriteDeadlineMock.callArgs = append(mmSetWriteDeadline.SetWriteDeadlineMock.callArgs, mm_params)
	mmSetWriteDeadline.SetWriteDeadlineMock.mutex.Unlock()

	for _, e := range mmSetWriteDeadline.SetWriteDeadlineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.params
		mm_got := ConnMockSetWriteDeadlineParams{t}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetWriteDeadline.t.Errorf("ConnMock.SetWriteDeadline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetWriteDeadline.t.Fatal("No results are set for the ConnMock.SetWriteDeadline")
		}
		return (*mm_results).err
	}
	if mmSetWriteDeadline.funcSetWriteDeadline != nil {
		return mmSetWriteDeadline.funcSetWriteDeadline(t)
	}
	mmSetWriteDeadline.t.Fatalf("Unexpected call to ConnMock.SetWriteDeadline. %v", t)
	return
}

// SetWriteDeadlineAfterCounter returns a count of finished ConnMock.SetWriteDeadline invocations
func (mmSetWriteDeadline *ConnMock) SetWriteDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetWriteDeadline.afterSetWriteDeadlineCounter)
}

// SetWriteDeadlineBeforeCounter returns a count of ConnMock.SetWriteDeadline invocations
func (mmSetWriteDeadline *ConnMock) SetWriteDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetWriteDeadline.beforeSetWriteDeadlineCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.SetWriteDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Calls() []*ConnMockSetWriteDeadlineParams {
	mmSetWriteDeadline.mutex.RLock()

	argCopy := make([]*ConnMockSetWriteDeadlineParams, len(mmSetWriteDeadline.callArgs))
	copy(argCopy, mmSetWriteDeadline.callArgs)

	mmSetWriteDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetWriteDeadlineDone returns true if the count of the SetWriteDeadline invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockSetWriteDeadlineDone() bool {
	for _, e := range m.SetWriteDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetWriteDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetWriteDeadline != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetWriteDeadlineInspect logs each unmet expectation
func (m *ConnMock) MinimockSetWriteDeadlineInspect() {
	for _, e := range m.SetWriteDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.SetWriteDeadline with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetWriteDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		if m.SetWriteDeadlineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.SetWriteDeadline")
		} else {
			m.t.Errorf("Expected call to ConnMock.SetWriteDeadline with params: %#v", *m.SetWriteDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetWriteDeadline != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		m.t.Error("Expected call to ConnMock.SetWriteDeadline")
	}
}

type mConnMockWrite struct {
	mock               *ConnMock
	defaultExpectation *ConnMockWriteExpectation
	expectations       []*ConnMockWriteExpectation

	callArgs []*ConnMockWriteParams
	mutex    sync.RWMutex
}

// ConnMockWriteExpectation specifies expectation struct of the Conn.Write
type ConnMockWriteExpectation struct {
	mock    *ConnMock
	params  *ConnMockWriteParams
	results *ConnMockWriteResults
	Counter uint64
}

// ConnMockWriteParams contains parameters of the Conn.Write
type ConnMockWriteParams struct {
	b []byte
}

// ConnMockWriteResults contains results of the Conn.Write
type ConnMockWriteResults struct {
	n   int
	err error
}

// Expect sets up expected params for Conn.Write
func (mmWrite *mConnMockWrite) Expect(b []byte) *mConnMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &ConnMockWriteExpectation{}
	}

	mmWrite.defaultExpectation.params = &ConnMockWriteParams{b}
	for _, e := range mmWrite.expectations {
		if minimock.Equal(e.params, mmWrite.defaultExpectation.params) {
			mmWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWrite.defaultExpectation.params)
		}
	}

	return mmWrite
}

// Inspect accepts an inspector function that has same arguments as the Conn.Write
func (mmWrite *mConnMockWrite) Inspect(f func(b []byte)) *mConnMockWrite {
	if mmWrite.mock.inspectFuncWrite != nil {
		mmWrite.mock.t.Fatalf("Inspect function is already set for ConnMock.Write")
	}

	mmWrite.mock.inspectFuncWrite = f

	return mmWrite
}

// Return sets up results that will be returned by Conn.Write
func (mmWrite *mConnMockWrite) Return(n int, err error) *ConnMock {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &ConnMockWriteExpectation{mock: mmWrite.mock}
	}
	mmWrite.defaultExpectation.results = &ConnMockWriteResults{n, err}
	return mmWrite.mock
}

//Set uses given function f to mock the Conn.Write method
func (mmWrite *mConnMockWrite) Set(f func(b []byte) (n int, err error)) *ConnMock {
	if mmWrite.defaultExpectation != nil {
		mmWrite.mock.t.Fatalf("Default expectation is already set for the Conn.Write method")
	}

	if len(mmWrite.expectations) > 0 {
		mmWrite.mock.t.Fatalf("Some expectations are already set for the Conn.Write method")
	}

	mmWrite.mock.funcWrite = f
	return mmWrite.mock
}

// When sets expectation for the Conn.Write which will trigger the result defined by the following
// Then helper
func (mmWrite *mConnMockWrite) When(b []byte) *ConnMockWriteExpectation {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Set")
	}

	expectation := &ConnMockWriteExpectation{
		mock:   mmWrite.mock,
		params: &ConnMockWriteParams{b},
	}
	mmWrite.expectations = append(mmWrite.expectations, expectation)
	return expectation
}

// Then sets up Conn.Write return parameters for the expectation previously defined by the When method
func (e *ConnMockWriteExpectation) Then(n int, err error) *ConnMock {
	e.results = &ConnMockWriteResults{n, err}
	return e.mock
}

// Write implements net.Conn
func (mmWrite *ConnMock) Write(b []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmWrite.beforeWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmWrite.afterWriteCounter, 1)

	if mmWrite.inspectFuncWrite != nil {
		mmWrite.inspectFuncWrite(b)
	}

	mm_params := &ConnMockWriteParams{b}

	// Record call args
	mmWrite.WriteMock.mutex.Lock()
	mmWrite.WriteMock.callArgs = append(mmWrite.WriteMock.callArgs, mm_params)
	mmWrite.WriteMock.mutex.Unlock()

	for _, e := range mmWrite.WriteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWrite.WriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWrite.WriteMock.defaultExpectation.Counter, 1)
		mm_want := mmWrite.WriteMock.defaultExpectation.params
		mm_got := ConnMockWriteParams{b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWrite.t.Errorf("ConnMock.Write got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWrite.WriteMock.defaultExpectation.results
		if mm_results == nil {
			mmWrite.t.Fatal("No results are set for the ConnMock.Write")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWrite.funcWrite != nil {
		return mmWrite.funcWrite(b)
	}
	mmWrite.t.Fatalf("Unexpected call to ConnMock.Write. %v", b)
	return
}

// WriteAfterCounter returns a count of finished ConnMock.Write invocations
func (mmWrite *ConnMock) WriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.afterWriteCounter)
}

// WriteBeforeCounter returns a count of ConnMock.Write invocations
func (mmWrite *ConnMock) WriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.beforeWriteCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.Write.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWrite *mConnMockWrite) Calls() []*ConnMockWriteParams {
	mmWrite.mutex.RLock()

	argCopy := make([]*ConnMockWriteParams, len(mmWrite.callArgs))
	copy(argCopy, mmWrite.callArgs)

	mmWrite.mutex.RUnlock()

	return argCopy
}

// MinimockWriteDone returns true if the count of the Write invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockWriteDone() bool {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteInspect logs each unmet expectation
func (m *ConnMock) MinimockWriteInspect() {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.Write with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		if m.WriteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConnMock.Write")
		} else {
			m.t.Errorf("Expected call to ConnMock.Write with params: %#v", *m.WriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		m.t.Error("Expected call to ConnMock.Write")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConnMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockLocalAddrInspect()

		m.MinimockReadInspect()

		m.MinimockRemoteAddrInspect()

		m.MinimockSetDeadlineInspect()

		m.MinimockSetReadDeadlineInspect()

		m.MinimockSetWriteDeadlineInspect()

		m.MinimockWriteInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConnMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConnMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockLocalAddrDone() &&
		m.MinimockReadDone() &&
		m.MinimockRemoteAddrDone() &&
		m.MinimockSetDeadlineDone() &&
		m.MinimockSetReadDeadlineDone() &&
		m.MinimockSetWriteDeadlineDone() &&
		m.MinimockWriteDone()
}
